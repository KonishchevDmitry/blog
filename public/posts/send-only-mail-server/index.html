<!DOCTYPE html>
<html lang="ru" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Настраиваем сервер исходящей почты для отправки уведомлений | Dmitry Konishchev&#39;s small blog</title>
<meta name="keywords" content="">
<meta name="description" content="Моя ситуация: есть домашний сервер, на котором настроено несколько десятков Prometheus-алертов &#43; cron job&rsquo;ы, рассылающие уведомления на почту. Хочется, чтобы все эти уведомления попадали на мою Gmail-почту и не помечались как спам.
Лет десять назад я себе это всё как-то настроил, но с тех пор прошло слишком много времени – у почтовых сервисов появился ряд требований, которым должен удовлетворять сервер исходящей почты, поэтому пришло время обновить свою конфигурацию, чтобы она соответствовала современным стандартам. Поделюсь набором шагов, как это можно сделать.">
<meta name="author" content="">
<link rel="canonical" href="https://konishchev.ru/posts/send-only-mail-server/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.27b0fc6a9e4df4110536f685cccf8ca9977c200af0d8eceaa8e77a5d07235262.css" integrity="sha256-J7D8ap5N9BEFNvaFzM&#43;MqZd8IArw2OzqqOd6XQcjUmI=" rel="preload stylesheet" as="style">

<!-- Console icon by Icons8 (https://icons8.com/icon/pSUzrDn0xTlh/console) -->

<link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/32.png">
<link rel="icon" type="image/png" sizes="72x72" href="/images/favicon/72.png">
<link rel="icon" type="image/png" sizes="96x96" href="/images/favicon/96.png">

<link rel="apple-touch-icon" type="image/png" sizes="57x57" href="/images/favicon/57.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="/images/favicon/60.png">
<link rel="apple-touch-icon" type="image/png" sizes="72x72" href="/images/favicon/72.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="/images/favicon/76.png">


<link rel="alternate" hreflang="ru" href="https://konishchev.ru/posts/send-only-mail-server/">

<meta name="twitter:title" content="Настраиваем сервер исходящей почты для отправки уведомлений | Dmitry Konishchev&#39;s small blog" />
<meta name="twitter:description" content="Моя ситуация: есть домашний сервер, на котором настроено несколько десятков Prometheus-алертов &#43; cron job&rsquo;ы, рассылающие уведомления на почту. Хочется, чтобы все эти уведомления попадали на мою Gmail-почту и не помечались как спам.
Лет десять назад я себе это всё как-то настроил, но с тех пор прошло слишком много времени – у почтовых сервисов появился ряд требований, которым должен удовлетворять сервер исходящей почты, поэтому пришло время обновить свою конфигурацию, чтобы она соответствовала современным стандартам. Поделюсь набором шагов, как это можно сделать." />
<meta property="og:title" content="Настраиваем сервер исходящей почты для отправки уведомлений | Dmitry Konishchev&#39;s small blog" />
<meta property="og:description" content="Моя ситуация: есть домашний сервер, на котором настроено несколько десятков Prometheus-алертов &#43; cron job&rsquo;ы, рассылающие уведомления на почту. Хочется, чтобы все эти уведомления попадали на мою Gmail-почту и не помечались как спам.
Лет десять назад я себе это всё как-то настроил, но с тех пор прошло слишком много времени – у почтовых сервисов появился ряд требований, которым должен удовлетворять сервер исходящей почты, поэтому пришло время обновить свою конфигурацию, чтобы она соответствовала современным стандартам. Поделюсь набором шагов, как это можно сделать." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://konishchev.ru/posts/send-only-mail-server/" />
<meta property="article:section" content="posts" />
  <meta property="article:published_time" content="2024-05-18T17:05:01&#43;03:00" />
  <meta property="article:modified_time" content="2024-05-18T19:36:15&#43;03:00" />


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://konishchev.ru/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Настраиваем сервер исходящей почты для отправки уведомлений",
      "item": "https://konishchev.ru/posts/send-only-mail-server/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Настраиваем сервер исходящей почты для отправки уведомлений | Dmitry Konishchev's small blog",
  "name": "Настраиваем сервер исходящей почты для отправки уведомлений",
  "description": "Моя ситуация: есть домашний сервер, на котором настроено несколько десятков Prometheus-алертов + cron job\u0026rsquo;ы, рассылающие уведомления на почту. Хочется, чтобы все эти уведомления попадали на мою Gmail-почту и не помечались как спам.\nЛет десять назад я себе это всё как-то настроил, но с тех пор прошло слишком много времени – у почтовых сервисов появился ряд требований, которым должен удовлетворять сервер исходящей почты, поэтому пришло время обновить свою конфигурацию, чтобы она соответствовала современным стандартам. Поделюсь набором шагов, как это можно сделать.\n",
  "keywords": [
    
  ],
  "wordCount" : "1831",
  "inLanguage": "ru",
  "datePublished": "2024-05-18T17:05:01+03:00",
  "dateModified": "2024-05-18T19:36:15+03:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://konishchev.ru/posts/send-only-mail-server/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Dmitry Konishchev's small blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://konishchev.ru/favicon.ico"
    }
  }
}
</script>
<script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();
    for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
    k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(96897335, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true
    });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/96897335" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>

</head>

<body class=" type-posts kind-page layout-" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://konishchev.ru/" accesskey="h" title="Dmitry Konishchev&#39;s small blog (Alt + H)">Dmitry Konishchev&#39;s small blog</a>
            <span class="logo-switches">
            </span>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main post">

<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">Настраиваем сервер исходящей почты для отправки уведомлений</h1>
    <div class="post-meta"><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select: text;"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select: text;"></rect><line x1="16" y1="2" x2="16" y2="6" style="user-select: text;"></line><line x1="8" y1="2" x2="8" y2="6" style="user-select: text;"></line><line x1="3" y1="10" x2="21" y2="10" style="user-select: text;"></line></svg>
  <span>18 мая 2024</span></span>
&nbsp;|&nbsp;<span class="meta-item">
    <span class="edit-post">
        <a href="https://github.com/KonishchevDmitry/blog/tree/master/content/posts/2024-05-18-send-only-mail-server.md" rel="noopener noreferrer" target="_blank">Исправить опечатку</a>
    </span>
</span>

      
    </div>
  </header> <div class="toc side right">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Оглавление</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#postfix" aria-label="Postfix">Postfix</a><ul>
                        
                <li>
                    <a href="#%d0%bf%d1%80%d0%be%d0%b2%d0%b5%d1%80%d0%ba%d0%b0-%d0%bf%d0%b5%d1%80%d0%b5%d1%81%d1%8b%d0%bb%d0%ba%d0%b8" aria-label="Проверка пересылки">Проверка пересылки</a></li>
                <li>
                    <a href="#%d0%bf%d1%80%d0%be%d0%b2%d0%b5%d1%80%d0%ba%d0%b0-%d0%bb%d0%be%d0%ba%d0%b0%d0%bb%d1%8c%d0%bd%d0%be%d0%b9-%d0%b4%d0%be%d1%81%d1%82%d0%b0%d0%b2%d0%ba%d0%b8" aria-label="Проверка локальной доставки">Проверка локальной доставки</a></li></ul>
                </li>
                <li>
                    <a href="#spf-dkim-dmark" aria-label="SPF, DKIM, DMARK">SPF, DKIM, DMARK</a><ul>
                        
                <li>
                    <a href="#ptr" aria-label="PTR">PTR</a></li>
                <li>
                    <a href="#spf" aria-label="SPF">SPF</a></li>
                <li>
                    <a href="#dkim" aria-label="DKIM">DKIM</a></li>
                <li>
                    <a href="#dmark" aria-label="DMARK">DMARK</a></li></ul>
                </li>
                <li>
                    <a href="#%d0%b7%d0%b0%d0%ba%d0%bb%d1%8e%d1%87%d0%b8%d1%82%d0%b5%d0%bb%d1%8c%d0%bd%d1%8b%d0%b5-%d1%88%d0%b0%d0%b3%d0%b8" aria-label="Заключительные шаги">Заключительные шаги</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Моя ситуация: есть домашний сервер, на котором настроено несколько десятков Prometheus-алертов + cron job&rsquo;ы, рассылающие уведомления на почту. Хочется, чтобы все эти уведомления попадали на мою Gmail-почту и не помечались как спам.</p>
<p>Лет десять назад я себе это всё как-то настроил, но с тех пор прошло слишком много времени – у почтовых сервисов появился ряд требований, которым должен удовлетворять сервер исходящей почты, поэтому пришло время обновить свою конфигурацию, чтобы она соответствовала современным стандартам. Поделюсь набором шагов, как это можно сделать.</p>
<p>На всякий случай сразу оговорюсь, что почти всё написанное ниже подразумевает, что у вас есть свой личный домен, с которого вы будете отправлять почту, т. к. ни один уважающий себя почтовый сервис не будет серьёзно относиться к письмам, отправленным с условного localhost&rsquo;а, и будет (хотя бы периодически) расценивать их как спам. Домен стоит не так уж и дорого – конкретно в моём случае это 250 руб. в год, что является вполне приемлемой суммой даже для домашнего сервера.</p>
<p>Настройка ниже предполагает, что мы хотим только отсылать почту, но не принимать её извне. В случае рассылки алертов это абсолютно не нужно, а получение почты извне добавляет массу ненужной сложности (к примеру, борьбу со спамом). И, как правило, если мы действительно хотим получать письма извне, то самым лучшим вариантом тут будет воспользоваться почтой для домена от одного из почтовых сервисов, т. к., как минимум, вместе с ней у вас будет удобный web-интерфейс и вполне сносная защита от спама. При этом такая почта для домена может без проблем сосуществовать с приведённой ниже конфигурацией: живые люди будут пользоваться её web-интерфейсом, а сервисы на вашем сервере – рассылать алерты через настроенный почтовый сервер.</p>
<p>Пример настройки будет описан для Ubuntu, но завязок на конкретный дистрибутив, как таковых, не будет. В качестве имени домена везде ниже буду использовать example.com.</p>
<h2 id="postfix">Postfix<a hidden class="anchor" aria-hidden="true" href="#postfix">¶</a></h2>
<p>В качестве почтового сервера будем использовать <a href="https://www.postfix.org/">Postfix</a>. Рекомендую почитать на сайте их документацию – она достаточно подробная и даёт понимание, как оно работает под капотом.</p>
<p>Итак, ставим пакет:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt install postfix
</span></span></code></pre></div><p>В случае с Debian/Ubuntu он запустит интерактивный скрипт <code>dpkg-preconfigure</code>, который сгенерит нам базовую конфигурацию. В отобразившемся диалоге выбираем &ldquo;Internet Site&rdquo; и вводим имя своего домена. Особого смысла в этой конфигурации для нас нет, т. к. мы всё равно ниже всё переконфигурим, и пожалуй единственное что от неё останется – это Debian-specific файл <code>/etc/mailname</code>, в который будет прописано имя нашего домена, чтобы его могли использовать почтовые клиенты.</p>
<p>У Postfix два основных конфигурационных файла:</p>
<ul>
<li><code>/etc/postfix/master.cf</code>, который описывает, как именно будут запускаться различные демоны, из которых состоит почтовый сервер. Его лучше не трогать и менять только тогда, когда вы действительно знаете, что делаете.</li>
<li><code>/etc/postfix/main.cf</code> – в нём будут храниться все основные настройки.</li>
</ul>
<p>Заменяем <code>/etc/postfix/main.cf</code> следующим содержимым:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cfg" data-lang="cfg"><span style="display:flex;"><span><span style="color:#008000"># man 5 postconf</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># See http://www.postfix.org/COMPATIBILITY_README.html</span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># Restart postfix server and look into /var/log/mail.log for complains about new defaults</span>
</span></span><span style="display:flex;"><span>compatibility_level = <span style="color:#a31515">3.8</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># Used in default values of many variables. Specifies what domain to use for outbound mail</span>
</span></span><span style="display:flex;"><span>myhostname = <span style="color:#a31515">example.com</span>
</span></span><span style="display:flex;"><span>mydomain = <span style="color:#a31515">$myhostname</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># Domains which will be delivered locally instead of forwarding to another machine</span>
</span></span><span style="display:flex;"><span>mydestination = <span style="color:#a31515">localhost $myhostname</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># Rewrite (possibly local) sender domain to our external domain</span>
</span></span><span style="display:flex;"><span>sender_canonical_maps = <span style="color:#a31515">static:@$myorigin</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># Interfaces to listen on</span>
</span></span><span style="display:flex;"><span>inet_interfaces = <span style="color:#a31515">loopback-only</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># Forward mail from local host only</span>
</span></span><span style="display:flex;"><span>mynetworks_style = <span style="color:#a31515">host</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># Redefine the default to disable NIS support</span>
</span></span><span style="display:flex;"><span>alias_maps = <span style="color:#a31515">hash:/etc/aliases</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># A little hardening</span>
</span></span><span style="display:flex;"><span>allow_mail_to_files =
</span></span><span style="display:flex;"><span>allow_mail_to_commands =
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># Relay mail only via TLS. Since it&#39;s too strict setting for generic server which should be able to send mail to any</span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># server on the Internet, it&#39;s reasonable when we send messages only to well-known servers like Gmail.</span>
</span></span><span style="display:flex;"><span>smtp_tls_security_level = <span style="color:#a31515">verify</span>
</span></span><span style="display:flex;"><span>smtp_tls_CApath=<span style="color:#a31515">/etc/ssl/certs</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># Generate delayed mail warnings</span>
</span></span><span style="display:flex;"><span>delay_warning_time = <span style="color:#a31515">4h</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># Errors to notify postmaster@ about</span>
</span></span><span style="display:flex;"><span>notify_classes = <span style="color:#a31515">2bounce, data, delay, policy, protocol, resource, software</span>
</span></span></code></pre></div><p>Здесь необходимо прописать в <code>myhostname</code> ваш домен, а также перечислить в <code>mydestination</code> все домены, с которых локальные сервисы могут прислать почту.</p>
<p>Логика тут следующая: если в <code>To:</code> письма указано только имя пользователя (скажем <code>dmitry</code>), то Postfix автоматом понимает, что это письмо предназначено для нашего домена (локальной доставки), но если в качестве имени пользователя указано, скажем, <code>dmitry@server</code>, то необходимо проинструктировать Postfix, что <code>server</code> – это на самом деле тоже наш домен. Необходимость в этом возникает, к примеру, когда hostname вашего сервера (значение в <code>/etc/hostname</code>) отличается от почтового домена, и неправильно настроенная программа отправки почты может генерировать <code>To</code>-адреса используя это имя сервера.</p>
<p>Далее заводим пользователя <code>postmaster</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo useradd -d /nonexistent -s /usr/sbin/nologin -r postmaster
</span></span></code></pre></div><p>Это well-known имя пользователя, которому Postfix будет посылать сообщения о различных ошибках (например, доставки почты).</p>
<p>Заменяем <code>/etc/aliases</code> следущим содержимым:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cfg" data-lang="cfg"><span style="display:flex;"><span><span style="color:#008000"># man 5 aliases</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>root:   example@gmail.com
</span></span><span style="display:flex;"><span>dmitry: example@gmail.com
</span></span></code></pre></div><p>Логика тут следующая: у нас есть два активных пользователя – <code>root</code> и <code>dmitry</code>, которым система может слать почтовые сообщения. В моём случае это преимущественно <code>cron</code>, который отсылает stdout/stderr своих джоб пользователю по почте, но, к примеру, их также шлёт <code>sudo</code>, если 3 раза неправильно ввести пароль. Данные директивы говорят Postfix о том, что необходимо принимать почту для этих двух пользователей не локально, а пересылать её на наш Gmail-ящик.</p>
<p>Если же Postfix не сможет доставить почту по данным адресам (Gmail отклонит её по какой-то причине), то информация об этом будет направлена пользователю <code>postmaster</code>.</p>
<p>Несмотря на то, что в <code>main.cf</code> у нас прописан <code>/etc/aliases</code>, Postfix будет считывать файл <code>/etc/aliases.db</code>, который является скомпилированным бинарным представлением этого конфига. Поэтому после каждой правки <code>/etc/aliases</code> необходимо запускать <code>sudo newaliases</code>, чтобы она создала <code>/etc/aliases.db</code>.</p>
<p>На этом базовая настройка закончена. Перезапускаем сервер и смотрим в его лог:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl restart postfix &amp;&amp; sudo tail -f /var/log/mail.log
</span></span></code></pre></div><h3 id="проверка-пересылки">Проверка пересылки<a hidden class="anchor" aria-hidden="true" href="#проверка-пересылки">¶</a></h3>
<p>Проверяем:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt install mutt
</span></span><span style="display:flex;"><span>mutt -s <span style="color:#a31515">&#39;Test mail&#39;</span> <span style="color:#a31515">&#34;</span><span style="color:#00f">$(</span>whoami<span style="color:#00f">)</span><span style="color:#a31515">&#34;</span> &lt;&lt;&lt; <span style="color:#a31515">&#39;Message body&#39;</span>
</span></span></code></pre></div><p>– письмо должно уйти на наш Gmail-аккаунт.</p>
<h3 id="проверка-локальной-доставки">Проверка локальной доставки<a hidden class="anchor" aria-hidden="true" href="#проверка-локальной-доставки">¶</a></h3>
<p>Чтобы быть в курсе всех проблем с отправкой почты, я выставил пользователю <code>root</code> переменную окружения <code>MAIL=/var/mail/postmaster</code>: своего ящика у него всё равно больше нет (вся почта перенаправляется в Gmail), но зато теперь bash будет автоматически уведомлять меня о всех новых сообщениях пользователя <code>postmaster</code>.</p>
<p>Проверяем работу данной схемы:</p>
<ol>
<li>Логинимся под <code>root</code>.</li>
<li>От любого пользователя запускаем <code>mutt -s 'Test mail' postmaster &lt;&lt;&lt; 'Message body'</code>.</li>
<li>root&rsquo;овый bash должен написать в терминал <code>You have mail in /var/mail/postmaster</code>.</li>
<li>Смотрим почту (к примеру, при помощи того же <code>mutt</code>).</li>
</ol>
<h2 id="spf-dkim-dmark">SPF, DKIM, DMARK<a hidden class="anchor" aria-hidden="true" href="#spf-dkim-dmark">¶</a></h2>
<p>Базовая настройка завершена, почта успешно уходит в Gmail, но с большой вероятностью будет попадать в спам. Всё потому, что наш сервер не удовлетворяет <a href="https://support.google.com/a/answer/81126">требованиям Gmail</a>.</p>
<p>Рекомендую почитать какой-нибудь tutorial по SPF/DKIM/DMARK, о которых пойдёт речь ниже, чтобы было понимание, что именно мы будем делать. К примеру, вот <a href="https://dmarcly.com/blog/how-to-implement-dmarc-dkim-spf-to-stop-email-spoofing-phishing-the-definitive-guide">этот</a>.</p>
<h3 id="ptr">PTR<a hidden class="anchor" aria-hidden="true" href="#ptr">¶</a></h3>
<p>Первым делом стоит удостовериться, что у вашего сервера правильная <a href="https://en.wikipedia.org/wiki/Reverse_DNS_lookup">PTR-запись</a>. Не всегда есть возможность её поменять – у меня, к примеру, в силу определённых причин её нету, и мне (пока?) это не мешает, но почтовые сервисы на неё точно смотрят, и желательно, чтобы она указывала на ваш домен.</p>
<h3 id="spf">SPF<a hidden class="anchor" aria-hidden="true" href="#spf">¶</a></h3>
<p>С помощью <a href="https://en.wikipedia.org/wiki/Sender_Policy_Framework">SPF</a> мы зададим список IP-адресов, с которых можно отсылать письма от имени нашего домена.</p>
<p>Добавляем следующую DNS-запись:</p>
<pre tabindex="0"><code>example.com. IN TXT &#34;v=spf1 a ~all&#34;
</code></pre><p>которая разрешает отправлять их только с тех IP, в которые резолвится наш <code>example.com</code>. Я использую <code>~all</code> вместо <code>-all</code>, т. к. в моём случае вряд ли кто-то будет заниматься спуфингом от моего имени, и в случае какой-то мисконфигурации я бы предпочёл получить свои письма в спам, чем не получить их вовсе.</p>
<p>Если вам хочется задать другие правила, то можно воспользоваться <a href="https://dmarcly.com/tools/spf-record-generator">SPF-генератором</a>.</p>
<h3 id="dkim">DKIM<a hidden class="anchor" aria-hidden="true" href="#dkim">¶</a></h3>
<p><a href="https://en.wikipedia.org/wiki/DomainKeys_Identified_Mail">DKIM</a> – это механизм подписи всех исходящих писем, с помощью которого получающая сторона может убедиться, что данные письма были присланы именно нашим сервером.</p>
<p>Реализовывать его будем с помощью <a href="http://www.opendkim.org/">OpenDKIM</a>.</p>
<p>Ставим пакет:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt install opendkim
</span></span></code></pre></div><p>Генерируем ключи:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo opendkim-genkey --domain example.com --selector server --nosubdomains --restrict --directory /etc/dkimkeys
</span></span></code></pre></div><p><code>server</code> здесь – это DKIM selector – произвольный идентификатор ключа. Нужен он потому, что их может быть несколько: у каждого сервера по ключу, либо в целях периодической ротации ключей.</p>
<p>Смотрим в <code>/etc/dkimkeys/server.txt</code> и прописываем получившуюся запись в DNS. Тут, правда, вас может ждать неудача: запись получается довольно длинная, и некоторые хостеры (к примеру, мой) просто отказываются её принимать. В таком случае можно сгенерировать чуть менее безопасный ключ, который будет меньшего размера:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo opendkim-genkey --domain example.com --selector server --bits 1024 --nosubdomains --directory /etc/dkimkeys
</span></span></code></pre></div><p>Проверяем, что всё прописалось правильно:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo opendkim-testkey -d example.com -s server -k /etc/dkimkeys/server.private
</span></span></code></pre></div><p>Меняем права на ключи:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo chown opendkim:opendkim /etc/dkimkeys/server.{private,txt}
</span></span></code></pre></div><p>и начинаем конфигурировать сам сервис.</p>
<p>В Debian/Ubuntu Postfix запускается в chroot&rsquo;е, и если UNIX-сокет OpenDKIM-сервера будет находиться вне его, то они просто не смогут общаться между собой. Поэтому содаём следующую директорию:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo install -d -o opendkim -g postfix -m 710 /var/spool/postfix/opendkim
</span></span><span style="display:flex;"><span>sudo chmod g+s /var/spool/postfix/opendkim
</span></span></code></pre></div><p>Создаём <code>/etc/systemd/system/opendkim.service</code> (конфигурация сервиса, которая поставляется с дистрибутивом, довольно странная – и лучше написать свою):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-systemd" data-lang="systemd"><span style="display:flex;"><span><span style="color:#00f">[Unit]</span>
</span></span><span style="display:flex;"><span>Description=<span style="color:#a31515">OpenDKIM Milter</span>
</span></span><span style="display:flex;"><span>Before=<span style="color:#a31515">postfix.service</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">[Service]</span>
</span></span><span style="display:flex;"><span>User=<span style="color:#a31515">opendkim</span>
</span></span><span style="display:flex;"><span>NoNewPrivileges=<span style="color:#a31515">true</span>
</span></span><span style="display:flex;"><span>MemoryDenyWriteExecute=<span style="color:#a31515">true</span>
</span></span><span style="display:flex;"><span>ProtectSystem=<span style="color:#a31515">true</span>
</span></span><span style="display:flex;"><span>PrivateTmp=<span style="color:#a31515">true</span>
</span></span><span style="display:flex;"><span>ExecStart=<span style="color:#a31515">/usr/sbin/opendkim</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">[Install]</span>
</span></span><span style="display:flex;"><span>WantedBy=<span style="color:#a31515">multi-user.target</span>
</span></span></code></pre></div><p>Заменяем <code>/etc/opendkim.conf</code> на:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cfg" data-lang="cfg"><span style="display:flex;"><span>Background no
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Syslog yes
</span></span><span style="display:flex;"><span>SyslogSuccess yes
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Mode s
</span></span><span style="display:flex;"><span>Domain example.com
</span></span><span style="display:flex;"><span>Selector server
</span></span><span style="display:flex;"><span>KeyFile /etc/dkimkeys/server.private
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># Postfix chroots into /var/spool/postfix, so we have to create SGID directory there and use permissive umask</span>
</span></span><span style="display:flex;"><span>Socket local:/var/spool/postfix/opendkim/opendkim.sock
</span></span><span style="display:flex;"><span>UMask 007
</span></span></code></pre></div><p>Добавляем в <code>/etc/postfix/main.cf</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cfg" data-lang="cfg"><span style="display:flex;"><span><span style="color:#008000"># DKIM signing</span>
</span></span><span style="display:flex;"><span>smtpd_milters = <span style="color:#a31515">unix:opendkim/opendkim.sock</span>
</span></span><span style="display:flex;"><span>non_smtpd_milters = <span style="color:#a31515">unix:opendkim/opendkim.sock</span>
</span></span></code></pre></div><p>Проверяем, работоспособность всей схемы:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl daemon-reload &amp;&amp; sudo systemctl restart opendkim postfix &amp;&amp; sudo tail -f /var/log/mail.log
</span></span><span style="display:flex;"><span>mutt -s <span style="color:#a31515">&#39;Test mail&#39;</span> <span style="color:#a31515">&#34;</span><span style="color:#00f">$(</span>whoami<span style="color:#00f">)</span><span style="color:#a31515">&#34;</span> &lt;&lt;&lt; <span style="color:#a31515">&#39;Message body&#39;</span>
</span></span></code></pre></div><h3 id="dmark">DMARK<a hidden class="anchor" aria-hidden="true" href="#dmark">¶</a></h3>
<p>Ну и последний штрих, который нам остался – это <a href="https://en.wikipedia.org/wiki/DMARC">DMARK</a>. Воспользуемся <a href="https://dmarcly.com/tools/dmarc-generator">DMARK-генератором</a> и получим следующую DNS-запись:</p>
<pre tabindex="0"><code>_dmarc IN TXT &#34;v=DMARC1; p=quarantine; sp=none; aspf=s; adkim=s;&#34;
</code></pre><p>Как и с SPF, для наших целей лучше подойдёт <code>p=quarantine</code>.</p>
<p>Email для aggregate/forensic reports не указываем, т. к. это опять-таки не наш случай:</p>
<ul>
<li>Aggregate Reports – это ежедневная рассылка XML-файлов, которая имеет смысл только если вы – какая-то большая организация и перенаправляете их в соответствующий сервис для последующего анализа.</li>
<li>Forensic Reports и вовсе не поддерживаются в Gmail.</li>
</ul>
<h2 id="заключительные-шаги">Заключительные шаги<a hidden class="anchor" aria-hidden="true" href="#заключительные-шаги">¶</a></h2>
<p>После того, как мы всё настроили, самое время пойти посмотреть, что про наши письма думают почтовые сервисы:</p>
<ol>
<li>Нажимаем на вертикальное троеточие в сообщении в Gmail и выбираем пункт &ldquo;Show original&rdquo; – там в самом верху будут статусы вида &ldquo;SPF/DKIM/DMARC: PASS&rdquo;, а также проверяем, что само сообщение не помечается красным флажком &ldquo;No encryption&rdquo; (в настройках Postfix мы указали отправку только по защищённому каналу). Есть ещё <a href="https://postmaster.google.com/">Google Postmaster Tools</a>, но они выглядят какими-то полузаброшенными: дашборд с графиками объявлен устаревшим и упорно отказывается показывать хоть какие-то графики даже после того, как я в течение недели слал себе каждую минуту какие-то сообщения (утверждается, что они могут не отображаться при небольшом количестве сообщений); в Compliance status в итоге все зелёные кружочки у меня загорелись, но только спустя неделю.</li>
<li>Заходим на <a href="https://www.mail-tester.com/">mail-tester.com</a> и отправляем сообщение на адрес, который он нам предложит, используя команду вида <code>mutt -s 'Test mail' test-m2rbwe4su@srv1.mail-tester.com &lt;&lt;&lt; 'Message body'</code>. Высокого рейтинга нам в нём ждать не стоит: он проверяет содержимое сообщения на спам (и тогда надо отсылать что-то реальное, чтобы не поджечь их лампочки), а также у нас нет <code>MX</code>-записи для входящей почты, что в его понимании выглядит крайне подозрительным. Но наша цель тут – не попытаться получить максимальный рейтинг по всем параметрам, а убедиться, что его устраивает всё, что касается только отправки писем.</li>
</ol>
<p>В итоге, имеем конфигурацию, которая полностью устраивает Gmail. И если раньше в случае резкого всплеска сообщений от какой-то сломавшейся cron&rsquo;ячки он начинал периодически помещать их в спам, то теперь, сколько бы тестовых сообщений я не пытался отправить, такого не происходит.</p>


  </div>

  <footer class="post-footer">
  </footer>
    <div class="comments-separator"></div><script src="https://giscus.app/client.js"
        data-repo="KonishchevDmitry/blog"
        data-repo-id="R_kgDOLqoJ-g"
        data-category="Announcements"
        data-category-id="DIC_kwDOLqoJ-s4Cefph"
        data-mapping="pathname"
        data-strict="1"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="light"
        data-lang="en"
        crossorigin="anonymous"
        async>
</script>
</article>
    </main>
    
<footer class="footer"><div class="social-icons">
    <a href="mailto:konishchev@gmail.com" target="_blank" title="Email" style="box-shadow: none">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 21" fill="none" stroke="currentColor" stroke-width="2"
    stroke-linecap="round" stroke-linejoin="round">
    <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path>
    <polyline points="22,6 12,13 2,6"></polyline>
</svg>

    </a>
    <a href="https://github.com/KonishchevDmitry" target="_blank" title="GitHub" style="box-shadow: none">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
    stroke-linecap="round" stroke-linejoin="round">
    <path
        d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22">
    </path>
</svg>

    </a>
    <a href="https://www.linkedin.com/in/konishchev/" target="_blank" title="LinkedIn" style="box-shadow: none">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
    stroke-linecap="round" stroke-linejoin="round">
    <path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path>
    <rect x="2" y="9" width="4" height="12"></rect>
    <circle cx="4" cy="4" r="2"></circle>
</svg>

    </a>
    <a href="/rss.xml" target="_blank" title="RSS" style="box-shadow: none">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
    stroke-linecap="round" stroke-linejoin="round">
    <path d="M4 11a9 9 0 0 1 9 9" />
    <path d="M4 4a16 16 0 0 1 16 16" />
    <circle cx="5" cy="19" r="1" />
</svg>

    </a>
</div>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
    <path d="M12 6H0l6-6z" />
  </svg>
</a>



<script>
  (function () {
    let menu = document.getElementById('menu')
    if (menu) {
      menu.scrollLeft = localStorage.getItem("menu-scroll-position");
      menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
      }
    }

    const disableSmoothScroll = '' == '1';
    const enableInstantClick = '' == '1';
    
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches || disableSmoothScroll || enableInstantClick) {
      return;
    }
    
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
      anchor.addEventListener("click", function (e) {
        e.preventDefault();
        var id = this.getAttribute("href").substr(1);
        document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
          behavior: "smooth"
        });
        if (id === "top") {
          history.replaceState(null, null, " ");
        } else {
          history.pushState(null, null, `#${id}`);
        }
      });
    });
  })();
</script>
<script>
  var mybutton = document.getElementById("top-link");
  window.onscroll = function () {
    if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
      mybutton.style.visibility = "visible";
      mybutton.style.opacity = "1";
    } else {
      mybutton.style.visibility = "hidden";
      mybutton.style.opacity = "0";
    }
  };
</script>
<script>
  if (window.scrollListeners) {
    
    for (const listener of scrollListeners) {
      window.removeEventListener('scroll', listener)
    }
  }
  window.scrollListeners = []
</script>



<script src="/js/medium-zoom.min.js" data-no-instant
></script>
<script>
  document.querySelectorAll('pre > code').forEach((codeblock) => {
    const container = codeblock.parentNode.parentNode;

    const copybutton = document.createElement('button');
    copybutton.classList.add('copy-code');
    copybutton.innerText = 'копировать';

    function copyingDone() {
      copybutton.innerText = 'скопировано!';
      setTimeout(() => {
        copybutton.innerText = 'копировать';
      }, 2000);
    }

    copybutton.addEventListener('click', (cb) => {
      if ('clipboard' in navigator) {
        navigator.clipboard.writeText(codeblock.textContent);
        copyingDone();
        return;
      }

      const range = document.createRange();
      range.selectNodeContents(codeblock);
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
      try {
        document.execCommand('copy');
        copyingDone();
      } catch (e) { };
      selection.removeRange(range);
    });

    if (container.classList.contains("highlight")) {
      container.appendChild(copybutton);
    } else if (container.parentNode.firstChild == container) {
      
    } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
      
      codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
    } else {
      
      codeblock.parentNode.appendChild(copybutton);
    }
  });
</script>




<script>
  
  
  (function() {
    const enableTocScroll = '1' == '1'
    if (!enableTocScroll) {
      return
    }
    if (!document.querySelector('.toc')) {
      console.log('no toc found, ignore toc scroll')
      return
    }
    

    
    const scrollListeners = window.scrollListeners
    const headings = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id]');
    const activeClass = 'active';

    
    let activeHeading = headings[0];
    getLinkByHeading(activeHeading).classList.add(activeClass);

    const onScroll = () => {
      const passedHeadings = [];
      for (const h of headings) {
        
        if (getOffsetTop(h) < 5) {
          passedHeadings.push(h)
        } else {
          break;
        }
      }
      if (passedHeadings.length > 0) {
        newActiveHeading = passedHeadings[passedHeadings.length - 1];
      } else {
        newActiveHeading = headings[0];
      }
      if (activeHeading != newActiveHeading) {
        getLinkByHeading(activeHeading).classList.remove(activeClass);
        activeHeading = newActiveHeading;
        getLinkByHeading(activeHeading).classList.add(activeClass);
      }
    }

    let timer = null;
    const scrollListener = () => {
      if (timer !== null) {
        clearTimeout(timer)
      }
      timer = setTimeout(onScroll, 50)
    }
    window.addEventListener('scroll', scrollListener, false);
    scrollListeners.push(scrollListener)

    function getLinkByHeading(heading) {
      const id = encodeURI(heading.getAttribute('id')).toLowerCase();
      return document.querySelector(`.toc ul li a[href="#${id}"]`);
    }

    function getOffsetTop(heading) {
      if (!heading.getClientRects().length) {
        return 0;
      }
      let rect = heading.getBoundingClientRect();
      return rect.top
    }
  })();
  </script>

</body>

</html>
