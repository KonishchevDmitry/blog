<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Dmitry Konishchev&#39;s small blog</title>
    <link>https://konishchev.ru/</link>
    <description>Recent content on Dmitry Konishchev&#39;s small blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru</language>
    <lastBuildDate>Sun, 11 Aug 2024 21:02:01 +0300</lastBuildDate>
    <atom:link href="https://konishchev.ru/rss.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Автоматическая установка приложений из GitHub-релизов</title>
      <link>https://konishchev.ru/posts/binup/</link>
      <pubDate>Sun, 04 Aug 2024 14:51:41 +0300</pubDate>
      
      <guid>https://konishchev.ru/posts/binup/</guid>
      <description>По мере распространения Go и Rust появляется всё больше программ, которые состоят из одного бинарника без каких-либо нестандартных зависимостей, и которые мы устанавливаем руками, скачивая релиз с GitHub: либо потому, что данного приложения ещё нет в вашем дистрибутиве, либо потому, что просто хочется всегда иметь актуальную версию, а не ждать, когда её затянут в дистрибутив.
Ставить (а особенно обновлять) такие приложения руками – занятие неблагодарное, особенно когда их количество становится больше одного-двух – и хочется какой-то автоматизации.</description>
      <content:encoded><![CDATA[<p>По мере распространения Go и Rust появляется всё больше программ, которые состоят из одного бинарника без каких-либо нестандартных зависимостей, и которые мы устанавливаем руками, скачивая релиз с GitHub: либо потому, что данного приложения ещё нет в вашем дистрибутиве, либо потому, что просто хочется всегда иметь актуальную версию, а не ждать, когда её затянут в дистрибутив.</p>
<p>Ставить (а особенно обновлять) такие приложения руками – занятие неблагодарное, особенно когда их количество становится больше одного-двух – и хочется какой-то автоматизации. У меня таких программ около десятка, и довольно долгое время я пользовался различными наколеночными скриптами вроде <a href="https://github.com/KonishchevDmitry/dotfiles/blob/61c8e48e5eb41db1df4e55ab1e97f6c74552b6bc/bin/get-github-release">этого</a> для поддержания их актуальности. Но bash-скрипт – это всё-таки как-то несерьёзно, и поэтому всегда хотелось чего-то более управляемого в виде нормального приложения. Найти что-то готовое, что удовлетворяло бы всем моим потребностям, мне сходу не удалось – поэтому некоторое время назад решил пойти моим излюбленным путём и написать своё приложение под эту конкретную задачу.</p>
<h2 id="binup">binup</h2>
<p>Пара недель кодинга по вечерам – и родилась утилита <a href="https://github.com/KonishchevDmitry/binup">binup</a>. Сегодня я зарелизил версию 1.0.0 и полностью перешёл на неё со своих скриптов. Буду рад, если получившаяся тула будет полезна кому-то кроме меня.</p>
<p>Вот как она работает: вы создаёте конфигурационный файл <code>~/.config/binup/config.yaml</code> с примерно следующим содержимым, в котором описываете конкретное приложение (как его найти на GitHub):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span>tools:
</span></span><span style="display:flex;"><span>  binup:
</span></span><span style="display:flex;"><span>    project: KonishchevDmitry/binup
</span></span><span style="display:flex;"><span>    release_matcher: binup-linux-x64-*
</span></span></code></pre></div><p>&hellip; запускаете <code>binup install</code> или <code>binup upgrade</code> – и тула устанавливает, либо обновляет указанные вами приложения.</p>
<p>Работает <code>binup</code> довольно просто: она нигде не хранит никакую информацию об установленных приложениях, а вместо этого при запуске смотрит на их текущий статус: если нужного бинарника нет, то устанавливает его; если же есть, то пробует запустить приложение с <code>--version</code>, чтобы определить текущую версию приложения и сравнить её с последним релизом на GitHub. Если же версию определить не удалось (к примеру, программа вовсе может не поддерживать флаг <code>--version</code>), то <code>binup</code> ориентируется на время модификации файла, которое при установке приложения задаёт равным времени модификации релиза.</p>
<h2 id="конфигурация">Конфигурация</h2>
<p>Вот пример конфигурационного файла со всеми доступными на данный момент опциями:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#008000"># Path where to install the binaries (the default is ~/.local/bin)</span>
</span></span><span style="display:flex;"><span>path: /usr/local/bin
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>tools:
</span></span><span style="display:flex;"><span>  <span style="color:#008000"># Binary name</span>
</span></span><span style="display:flex;"><span>  prometheus:
</span></span><span style="display:flex;"><span>    <span style="color:#008000"># GitHub project name</span>
</span></span><span style="display:flex;"><span>    project: prometheus/prometheus
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#008000"># Changelog URL (will be printed on app upgrade)</span>
</span></span><span style="display:flex;"><span>    changelog: https://github.com/prometheus/prometheus/blob/main/CHANGELOG.md
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#008000"># Release archive pattern:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#008000"># * By default shell-like glob matching is used (https://docs.rs/globset/latest/globset/#syntax)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#008000"># * Pattern started with &#39;~&#39; is treated as regular expression (https://docs.rs/regex/latest/regex/#syntax)</span>
</span></span><span style="display:flex;"><span>    release_matcher: prometheus-*.linux-amd64.tar.gz
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#008000"># Binary path to look for inside the release archive. If it&#39;s not specified, the tool name will be used.</span>
</span></span><span style="display:flex;"><span>    binary_matcher: <span style="color:#a31515">&#34;*/prometheus&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#008000"># Post-install script</span>
</span></span><span style="display:flex;"><span>    post: systemctl restart prometheus
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># If you have a lot of tools, you may hit GitHub API rate limits for anonymous requests at some moment.</span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># So it&#39;s recommended to obtain GitHub token (https://github.com/settings/tokens) and specify it here.</span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># No permissions are required for the token – it&#39;s needed just to make API requests non-anonymous.</span>
</span></span><span style="display:flex;"><span>github:
</span></span><span style="display:flex;"><span>  token: $token
</span></span></code></pre></div><h2 id="последующее-развитие">Последующее развитие</h2>
<p>Развивать её в какой-то полноценный пакетный менеджер вроде <a href="https://brew.sh/">Homebrew</a> я точно не планирую, но вот в рамках решения вышеописанной задачи – вполне.</p>
<p>Пока что из наиболее явных потенциальных фичей видится поддержка GitLab, если возникнет такая необходимость (лично у меня пока что нет ни одного приложения с него), а также явно напрашивается генерация какого-то дефолтного <code>release_matcher</code>&lsquo;а в зависимости от текущей ОС и архитектуры.</p>
<p>Прямо сейчас она закрывает все мои потребности, но вполне вероятно, что в процессе использования будут возникать новые – и тогда буду закрывать и их.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Настраиваем сервер исходящей почты для отправки уведомлений</title>
      <link>https://konishchev.ru/posts/send-only-mail-server/</link>
      <pubDate>Sat, 18 May 2024 17:05:01 +0300</pubDate>
      
      <guid>https://konishchev.ru/posts/send-only-mail-server/</guid>
      <description>Моя ситуация: есть домашний сервер, на котором настроено несколько десятков Prometheus-алертов + cron job&amp;rsquo;ы, рассылающие уведомления на почту. Хочется, чтобы все эти уведомления попадали на мою Gmail-почту и не помечались как спам.
Лет десять назад я себе это всё как-то настроил, но с тех пор прошло слишком много времени – у почтовых сервисов появился ряд требований, которым должен удовлетворять сервер исходящей почты, поэтому пришло время обновить свою конфигурацию, чтобы она соответствовала современным стандартам.</description>
      <content:encoded><![CDATA[<p>Моя ситуация: есть домашний сервер, на котором настроено несколько десятков Prometheus-алертов + cron job&rsquo;ы, рассылающие уведомления на почту. Хочется, чтобы все эти уведомления попадали на мою Gmail-почту и не помечались как спам.</p>
<p>Лет десять назад я себе это всё как-то настроил, но с тех пор прошло слишком много времени – у почтовых сервисов появился ряд требований, которым должен удовлетворять сервер исходящей почты, поэтому пришло время обновить свою конфигурацию, чтобы она соответствовала современным стандартам. Поделюсь набором шагов, как это можно сделать.</p>
<p>На всякий случай сразу оговорюсь, что почти всё написанное ниже подразумевает, что у вас есть свой личный домен, с которого вы будете отправлять почту, т. к. ни один уважающий себя почтовый сервис не будет серьёзно относиться к письмам, отправленным с условного localhost&rsquo;а, и будет (хотя бы периодически) расценивать их как спам. Домен стоит не так уж и дорого – конкретно в моём случае это 250 руб. в год, что является вполне приемлемой суммой даже для домашнего сервера.</p>
<p>Настройка ниже предполагает, что мы хотим только отсылать почту, но не принимать её извне. В случае рассылки алертов это абсолютно не нужно, а получение почты извне добавляет массу ненужной сложности (к примеру, борьбу со спамом). И, как правило, если мы действительно хотим получать письма извне, то самым лучшим вариантом тут будет воспользоваться почтой для домена от одного из почтовых сервисов, т. к., как минимум, вместе с ней у вас будет удобный web-интерфейс и вполне сносная защита от спама. При этом такая почта для домена может без проблем сосуществовать с приведённой ниже конфигурацией: живые люди будут пользоваться её web-интерфейсом, а сервисы на вашем сервере – рассылать алерты через настроенный почтовый сервер.</p>
<p>Пример настройки будет описан для Ubuntu, но завязок на конкретный дистрибутив, как таковых, не будет. В качестве имени домена везде ниже буду использовать example.com.</p>
<h2 id="postfix">Postfix</h2>
<p>В качестве почтового сервера будем использовать <a href="https://www.postfix.org/">Postfix</a>. Рекомендую почитать на сайте их документацию – она достаточно подробная и даёт понимание, как оно работает под капотом.</p>
<p>Итак, ставим пакет:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt install postfix
</span></span></code></pre></div><p>В случае с Debian/Ubuntu он запустит интерактивный скрипт <code>dpkg-preconfigure</code>, который сгенерит нам базовую конфигурацию. В отобразившемся диалоге выбираем &ldquo;Internet Site&rdquo; и вводим имя своего домена. Особого смысла в этой конфигурации для нас нет, т. к. мы всё равно ниже всё переконфигурим, и пожалуй единственное что от неё останется – это Debian-specific файл <code>/etc/mailname</code>, в который будет прописано имя нашего домена, чтобы его могли использовать почтовые клиенты.</p>
<p>У Postfix два основных конфигурационных файла:</p>
<ul>
<li><code>/etc/postfix/master.cf</code>, который описывает, как именно будут запускаться различные демоны, из которых состоит почтовый сервер. Его лучше не трогать и менять только тогда, когда вы действительно знаете, что делаете.</li>
<li><code>/etc/postfix/main.cf</code> – в нём будут храниться все основные настройки.</li>
</ul>
<p>Заменяем <code>/etc/postfix/main.cf</code> следующим содержимым:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cfg" data-lang="cfg"><span style="display:flex;"><span><span style="color:#008000"># man 5 postconf</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># See http://www.postfix.org/COMPATIBILITY_README.html</span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># Restart postfix server and look into /var/log/mail.log for complains about new defaults</span>
</span></span><span style="display:flex;"><span>compatibility_level = <span style="color:#a31515">3.8</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># Used in default values of many variables. Specifies what domain to use for outbound mail</span>
</span></span><span style="display:flex;"><span>myhostname = <span style="color:#a31515">example.com</span>
</span></span><span style="display:flex;"><span>mydomain = <span style="color:#a31515">$myhostname</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># Domains which will be delivered locally instead of forwarding to another machine</span>
</span></span><span style="display:flex;"><span>mydestination = <span style="color:#a31515">localhost $myhostname</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># Rewrite (possibly local) sender domain to our external domain</span>
</span></span><span style="display:flex;"><span>sender_canonical_maps = <span style="color:#a31515">static:@$myorigin</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># Interfaces to listen on</span>
</span></span><span style="display:flex;"><span>inet_interfaces = <span style="color:#a31515">loopback-only</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># Forward mail from local host only</span>
</span></span><span style="display:flex;"><span>mynetworks_style = <span style="color:#a31515">host</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># Redefine the default to disable NIS support</span>
</span></span><span style="display:flex;"><span>alias_maps = <span style="color:#a31515">hash:/etc/aliases</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># A little hardening</span>
</span></span><span style="display:flex;"><span>allow_mail_to_files =
</span></span><span style="display:flex;"><span>allow_mail_to_commands =
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># Relay mail only via TLS. Since it&#39;s too strict setting for generic server which should be able to send mail to any</span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># server on the Internet, it&#39;s reasonable when we send messages only to well-known servers like Gmail.</span>
</span></span><span style="display:flex;"><span>smtp_tls_security_level = <span style="color:#a31515">verify</span>
</span></span><span style="display:flex;"><span>smtp_tls_CApath=<span style="color:#a31515">/etc/ssl/certs</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># Generate delayed mail warnings</span>
</span></span><span style="display:flex;"><span>delay_warning_time = <span style="color:#a31515">4h</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># Errors to notify postmaster@ about</span>
</span></span><span style="display:flex;"><span>notify_classes = <span style="color:#a31515">2bounce, data, delay, policy, protocol, resource, software</span>
</span></span></code></pre></div><p>Здесь необходимо прописать в <code>myhostname</code> ваш домен, а также перечислить в <code>mydestination</code> все домены, с которых локальные сервисы могут прислать почту.</p>
<p>Логика тут следующая: если в <code>To:</code> письма указано только имя пользователя (скажем <code>dmitry</code>), то Postfix автоматом понимает, что это письмо предназначено для нашего домена (локальной доставки), но если в качестве имени пользователя указано, скажем, <code>dmitry@server</code>, то необходимо проинструктировать Postfix, что <code>server</code> – это на самом деле тоже наш домен. Необходимость в этом возникает, к примеру, когда hostname вашего сервера (значение в <code>/etc/hostname</code>) отличается от почтового домена, и неправильно настроенная программа отправки почты может генерировать <code>To</code>-адреса используя это имя сервера.</p>
<p>Далее заводим пользователя <code>postmaster</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo useradd -d /nonexistent -s /usr/sbin/nologin -r postmaster
</span></span></code></pre></div><p>Это well-known имя пользователя, которому Postfix будет посылать сообщения о различных ошибках (например, доставки почты).</p>
<p>Заменяем <code>/etc/aliases</code> следущим содержимым:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cfg" data-lang="cfg"><span style="display:flex;"><span><span style="color:#008000"># man 5 aliases</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>root:   example@gmail.com
</span></span><span style="display:flex;"><span>dmitry: example@gmail.com
</span></span></code></pre></div><p>Логика тут следующая: у нас есть два активных пользователя – <code>root</code> и <code>dmitry</code>, которым система может слать почтовые сообщения. В моём случае это преимущественно <code>cron</code>, который отсылает stdout/stderr своих джоб пользователю по почте, но, к примеру, их также шлёт <code>sudo</code>, если 3 раза неправильно ввести пароль. Данные директивы говорят Postfix о том, что необходимо принимать почту для этих двух пользователей не локально, а пересылать её на наш Gmail-ящик.</p>
<p>Если же Postfix не сможет доставить почту по данным адресам (Gmail отклонит её по какой-то причине), то информация об этом будет направлена пользователю <code>postmaster</code>.</p>
<p>Несмотря на то, что в <code>main.cf</code> у нас прописан <code>/etc/aliases</code>, Postfix будет считывать файл <code>/etc/aliases.db</code>, который является скомпилированным бинарным представлением этого конфига. Поэтому после каждой правки <code>/etc/aliases</code> необходимо запускать <code>sudo newaliases</code>, чтобы она создала <code>/etc/aliases.db</code>.</p>
<p>На этом базовая настройка закончена. Перезапускаем сервер и смотрим в его лог:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl restart postfix &amp;&amp; sudo tail -f /var/log/mail.log
</span></span></code></pre></div><h3 id="проверка-пересылки">Проверка пересылки</h3>
<p>Проверяем:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt install mutt
</span></span><span style="display:flex;"><span>mutt -s <span style="color:#a31515">&#39;Test mail&#39;</span> <span style="color:#a31515">&#34;</span><span style="color:#00f">$(</span>whoami<span style="color:#00f">)</span><span style="color:#a31515">&#34;</span> &lt;&lt;&lt; <span style="color:#a31515">&#39;Message body&#39;</span>
</span></span></code></pre></div><p>– письмо должно уйти на наш Gmail-аккаунт.</p>
<h3 id="проверка-локальной-доставки">Проверка локальной доставки</h3>
<p>Чтобы быть в курсе всех проблем с отправкой почты, я выставил пользователю <code>root</code> переменную окружения <code>MAIL=/var/mail/postmaster</code>: своего ящика у него всё равно больше нет (вся почта перенаправляется в Gmail), но зато теперь bash будет автоматически уведомлять меня о всех новых сообщениях пользователя <code>postmaster</code>.</p>
<p>Проверяем работу данной схемы:</p>
<ol>
<li>Логинимся под <code>root</code>.</li>
<li>От любого пользователя запускаем <code>mutt -s 'Test mail' postmaster &lt;&lt;&lt; 'Message body'</code>.</li>
<li>root&rsquo;овый bash должен написать в терминал <code>You have mail in /var/mail/postmaster</code>.</li>
<li>Смотрим почту (к примеру, при помощи того же <code>mutt</code>).</li>
</ol>
<h2 id="spf-dkim-dmark">SPF, DKIM, DMARK</h2>
<p>Базовая настройка завершена, почта успешно уходит в Gmail, но с большой вероятностью будет попадать в спам. Всё потому, что наш сервер не удовлетворяет <a href="https://support.google.com/a/answer/81126">требованиям Gmail</a>.</p>
<p>Рекомендую почитать какой-нибудь tutorial по SPF/DKIM/DMARK, о которых пойдёт речь ниже, чтобы было понимание, что именно мы будем делать. К примеру, вот <a href="https://dmarcly.com/blog/how-to-implement-dmarc-dkim-spf-to-stop-email-spoofing-phishing-the-definitive-guide">этот</a>.</p>
<h3 id="ptr">PTR</h3>
<p>Первым делом стоит удостовериться, что у вашего сервера правильная <a href="https://en.wikipedia.org/wiki/Reverse_DNS_lookup">PTR-запись</a>. Не всегда есть возможность её поменять – у меня, к примеру, в силу определённых причин её нету, и мне (пока?) это не мешает, но почтовые сервисы на неё точно смотрят, и желательно, чтобы она указывала на ваш домен.</p>
<h3 id="spf">SPF</h3>
<p>С помощью <a href="https://en.wikipedia.org/wiki/Sender_Policy_Framework">SPF</a> мы зададим список IP-адресов, с которых можно отсылать письма от имени нашего домена.</p>
<p>Добавляем следующую DNS-запись:</p>
<pre tabindex="0"><code>example.com. IN TXT &#34;v=spf1 a ~all&#34;
</code></pre><p>которая разрешает отправлять их только с тех IP, в которые резолвится наш <code>example.com</code>. Я использую <code>~all</code> вместо <code>-all</code>, т. к. в моём случае вряд ли кто-то будет заниматься спуфингом от моего имени, и в случае какой-то мисконфигурации я бы предпочёл получить свои письма в спам, чем не получить их вовсе.</p>
<p>Если вам хочется задать другие правила, то можно воспользоваться <a href="https://dmarcly.com/tools/spf-record-generator">SPF-генератором</a>.</p>
<h3 id="dkim">DKIM</h3>
<p><a href="https://en.wikipedia.org/wiki/DomainKeys_Identified_Mail">DKIM</a> – это механизм подписи всех исходящих писем, с помощью которого получающая сторона может убедиться, что данные письма были присланы именно нашим сервером.</p>
<p>Реализовывать его будем с помощью <a href="http://www.opendkim.org/">OpenDKIM</a>.</p>
<p>Ставим пакет:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt install opendkim
</span></span></code></pre></div><p>Генерируем ключи:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo opendkim-genkey --domain example.com --selector server --nosubdomains --restrict --directory /etc/dkimkeys
</span></span></code></pre></div><p><code>server</code> здесь – это DKIM selector – произвольный идентификатор ключа. Нужен он потому, что их может быть несколько: у каждого сервера по ключу, либо в целях периодической ротации ключей.</p>
<p>Смотрим в <code>/etc/dkimkeys/server.txt</code> и прописываем получившуюся запись в DNS. Тут, правда, вас может ждать неудача: запись получается довольно длинная, и некоторые хостеры (к примеру, мой) просто отказываются её принимать. В таком случае можно сгенерировать чуть менее безопасный ключ, который будет меньшего размера:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo opendkim-genkey --domain example.com --selector server --bits 1024 --nosubdomains --directory /etc/dkimkeys
</span></span></code></pre></div><p>Проверяем, что всё прописалось правильно:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo opendkim-testkey -d example.com -s server -k /etc/dkimkeys/server.private
</span></span></code></pre></div><p>Меняем права на ключи:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo chown opendkim:opendkim /etc/dkimkeys/server.{private,txt}
</span></span></code></pre></div><p>и начинаем конфигурировать сам сервис.</p>
<p>В Debian/Ubuntu Postfix запускается в chroot&rsquo;е, и если UNIX-сокет OpenDKIM-сервера будет находиться вне его, то они просто не смогут общаться между собой. Поэтому содаём следующую директорию:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo install -d -o opendkim -g postfix -m 710 /var/spool/postfix/opendkim
</span></span><span style="display:flex;"><span>sudo chmod g+s /var/spool/postfix/opendkim
</span></span></code></pre></div><p>Создаём <code>/etc/systemd/system/opendkim.service</code> (конфигурация сервиса, которая поставляется с дистрибутивом, довольно странная – и лучше написать свою):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-systemd" data-lang="systemd"><span style="display:flex;"><span><span style="color:#00f">[Unit]</span>
</span></span><span style="display:flex;"><span>Description=<span style="color:#a31515">OpenDKIM Milter</span>
</span></span><span style="display:flex;"><span>Before=<span style="color:#a31515">postfix.service</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">[Service]</span>
</span></span><span style="display:flex;"><span>User=<span style="color:#a31515">opendkim</span>
</span></span><span style="display:flex;"><span>NoNewPrivileges=<span style="color:#a31515">true</span>
</span></span><span style="display:flex;"><span>MemoryDenyWriteExecute=<span style="color:#a31515">true</span>
</span></span><span style="display:flex;"><span>ProtectSystem=<span style="color:#a31515">true</span>
</span></span><span style="display:flex;"><span>PrivateTmp=<span style="color:#a31515">true</span>
</span></span><span style="display:flex;"><span>ExecStart=<span style="color:#a31515">/usr/sbin/opendkim</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">[Install]</span>
</span></span><span style="display:flex;"><span>WantedBy=<span style="color:#a31515">multi-user.target</span>
</span></span></code></pre></div><p>Заменяем <code>/etc/opendkim.conf</code> на:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cfg" data-lang="cfg"><span style="display:flex;"><span>Background no
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Syslog yes
</span></span><span style="display:flex;"><span>SyslogSuccess yes
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Mode s
</span></span><span style="display:flex;"><span>Domain example.com
</span></span><span style="display:flex;"><span>Selector server
</span></span><span style="display:flex;"><span>KeyFile /etc/dkimkeys/server.private
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># Postfix chroots into /var/spool/postfix, so we have to create SGID directory there and use permissive umask</span>
</span></span><span style="display:flex;"><span>Socket local:/var/spool/postfix/opendkim/opendkim.sock
</span></span><span style="display:flex;"><span>UMask 007
</span></span></code></pre></div><p>Добавляем в <code>/etc/postfix/main.cf</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cfg" data-lang="cfg"><span style="display:flex;"><span><span style="color:#008000"># DKIM signing</span>
</span></span><span style="display:flex;"><span>smtpd_milters = <span style="color:#a31515">unix:opendkim/opendkim.sock</span>
</span></span><span style="display:flex;"><span>non_smtpd_milters = <span style="color:#a31515">unix:opendkim/opendkim.sock</span>
</span></span></code></pre></div><p>Проверяем, работоспособность всей схемы:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl daemon-reload &amp;&amp; sudo systemctl restart opendkim postfix &amp;&amp; sudo tail -f /var/log/mail.log
</span></span><span style="display:flex;"><span>mutt -s <span style="color:#a31515">&#39;Test mail&#39;</span> <span style="color:#a31515">&#34;</span><span style="color:#00f">$(</span>whoami<span style="color:#00f">)</span><span style="color:#a31515">&#34;</span> &lt;&lt;&lt; <span style="color:#a31515">&#39;Message body&#39;</span>
</span></span></code></pre></div><h3 id="dmark">DMARK</h3>
<p>Ну и последний штрих, который нам остался – это <a href="https://en.wikipedia.org/wiki/DMARC">DMARK</a>. Воспользуемся <a href="https://dmarcly.com/tools/dmarc-generator">DMARK-генератором</a> и получим следующую DNS-запись:</p>
<pre tabindex="0"><code>_dmarc IN TXT &#34;v=DMARC1; p=quarantine; sp=none; aspf=s; adkim=s;&#34;
</code></pre><p>Как и с SPF, для наших целей лучше подойдёт <code>p=quarantine</code>.</p>
<p>Email для aggregate/forensic reports не указываем, т. к. это опять-таки не наш случай:</p>
<ul>
<li>Aggregate Reports – это ежедневная рассылка XML-файлов, которая имеет смысл только если вы – какая-то большая организация и перенаправляете их в соответствующий сервис для последующего анализа.</li>
<li>Forensic Reports и вовсе не поддерживаются в Gmail.</li>
</ul>
<h2 id="заключительные-шаги">Заключительные шаги</h2>
<p>После того, как мы всё настроили, самое время пойти посмотреть, что про наши письма думают почтовые сервисы:</p>
<ol>
<li>Нажимаем на вертикальное троеточие в сообщении в Gmail и выбираем пункт &ldquo;Show original&rdquo; – там в самом верху будут статусы вида &ldquo;SPF/DKIM/DMARC: PASS&rdquo;, а также проверяем, что само сообщение не помечается красным флажком &ldquo;No encryption&rdquo; (в настройках Postfix мы указали отправку только по защищённому каналу). Есть ещё <a href="https://postmaster.google.com/">Google Postmaster Tools</a>, но они выглядят какими-то полузаброшенными: дашборд с графиками объявлен устаревшим и упорно отказывается показывать хоть какие-то графики даже после того, как я в течение недели слал себе каждую минуту какие-то сообщения (утверждается, что они могут не отображаться при небольшом количестве сообщений); в Compliance status в итоге все зелёные кружочки у меня загорелись, но только спустя неделю.</li>
<li>Заходим на <a href="https://www.mail-tester.com/">mail-tester.com</a> и отправляем сообщение на адрес, который он нам предложит, используя команду вида <code>mutt -s 'Test mail' test-m2rbwe4su@srv1.mail-tester.com &lt;&lt;&lt; 'Message body'</code>. Высокого рейтинга нам в нём ждать не стоит: он проверяет содержимое сообщения на спам (и тогда надо отсылать что-то реальное, чтобы не поджечь их лампочки), а также у нас нет <code>MX</code>-записи для входящей почты, что в его понимании выглядит крайне подозрительным. Но наша цель тут – не попытаться получить максимальный рейтинг по всем параметрам, а убедиться, что его устраивает всё, что касается только отправки писем.</li>
</ol>
<p>В итоге, имеем конфигурацию, которая полностью устраивает Gmail. И если раньше в случае резкого всплеска сообщений от какой-то сломавшейся cron&rsquo;ячки он начинал периодически помещать их в спам, то теперь, сколько бы тестовых сообщений я не пытался отправить, такого не происходит.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>BBR: когда TCP &#34;быстрее&#34; UDP</title>
      <link>https://konishchev.ru/posts/tcp-bbr/</link>
      <pubDate>Fri, 19 Apr 2024 21:25:58 +0300</pubDate>
      
      <guid>https://konishchev.ru/posts/tcp-bbr/</guid>
      <description>Некоторое время назад, в связи со всем известными событиями, я решил защитить свой текущий тоннель до VPS в Нидерландах, для которого до этого использовал обычный WireGuard. Как это часто со мной бывает, я решил пойти не самым простым, но зато самым любимым мной путём – и написал свой тоннель. :) Идея эта была привлекательна тем, что давала мне возможность познакомиться с Tokio, побольше узнать о принципах работы tun/tap–интерфейсов в Linux, почитать исходники Shadowsocks, ну и в процессе даже удалось найти и поправить небольшую багу в networkd.</description>
      <content:encoded><![CDATA[<p>Некоторое время назад, в связи со всем известными событиями, я решил защитить свой текущий тоннель до VPS в Нидерландах, для которого до этого использовал обычный <a href="https://www.wireguard.com/">WireGuard</a>. Как это часто со мной бывает, я решил пойти не самым простым, но зато самым любимым мной путём – и написал свой тоннель. :) Идея эта была привлекательна тем, что давала мне возможность познакомиться с <a href="https://tokio.rs/">Tokio</a>, побольше узнать о принципах работы tun/tap–интерфейсов в Linux, почитать исходники <a href="https://shadowsocks.org/">Shadowsocks</a>, ну и в процессе даже удалось найти и поправить <a href="https://github.com/systemd/systemd/pull/30504">небольшую багу в networkd</a>. Но на самом деле речь в данном посте пойдёт не об этом.</p>
<p>Когда я писал свой тоннель, у меня было стойкое убеждение, что в качестве транспорта нужно прежде всего ориентироваться на UDP, а на TCP откатываться только в том случае, когда UDP перестаёт работать в силу тех или иных &ldquo;причин&rdquo;. И это вроде бы логично: в плане производительности для тоннеля UDP всегда предпочтительнее, т. к. он реализует именно то, что нам нужно – максимально тонкую обёртку над пакетами, а с TCP у нас начинается целый ворох проблем, начиная с <a href="https://openvpn.net/faq/what-is-tcp-meltdown/">TCP Meltdown</a> и заканчивая <a href="https://en.wikipedia.org/wiki/Head-of-line_blocking">head-of-line blocking</a>.</p>
<p>Но вот когда я начал думать, как можно подтюнить получившийся тоннель помимо включения довольно очевидных вещей вроде <a href="https://man7.org/linux/man-pages/man7/tcp.7.html">TCP_NODELAY</a>, то набрёл на BBR, который стал для меня очень приятным открытием.</p>
<h2 id="bbr">BBR</h2>
<p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=0f8782ea14974ce992618b55f0c041ef43ed0b78">BBR (Bottleneck Bandwidth and RTT)</a> – это алгоритм <a href="https://en.wikipedia.org/wiki/TCP_congestion_control">TCP congestion control</a>, разработанный в Google. В отличие от традиционных алгоритмов, которые ориентируются на потери пакетов, BBR пытается судить о загруженности канала, наблюдая за тем, как меняется скорость передачи данных и RTT. Сейчас сети уже не те, что были в 80-ых годах, и такой подход работает гораздо лучше, а особенно – в случае трансконтинентальных соединений, где у нас может быть довольно широкий канал, но при этом небольшой процент потерь пакетов является нормой (как в моём случае с дешёвым VPS).</p>
<p>В результате получается, что если у вас такой канал, где нередки небольшие потери пакетов, то это сильно сказывается на скорости TCP-соединения, т. к. эти потери расцениваются традиционными алгоритмами как сигнал к тому, что необходимо сбросить скорость до тех пор, пока они не сойдут на нет. К тому же, даже в случае когда потерь нет, но при этом TCP-соединение способно утилизировать весь канал передачи данных, традиционные алгоритмы склонны снижать скорость только тогда, когда буфер роутера (зачастую довольно большой) уже переполнен, и роутер начинает дропать пакеты, что по факту является сильно запоздалой реакцией, которая приводит к увеличению latency, а BBR как раз пытается этой ситуации избежать. Этой проблеме даже посвящен целый сайт <a href="https://www.bufferbloat.net/projects/">bufferbloat.net</a>.</p>
<p>Польза, которую BBR способен вам нанести по сравнению со стандартным CUBIC&rsquo;ом, сильно зависит от многих факторов, но вот, к примеру, отчёты Amazon и Google, которые свидетельствуют о том, что после включения BBR у них стабильно улучшились bandwidth и RTT: <a href="https://aws.amazon.com/blogs/networking-and-content-delivery/tcp-bbr-congestion-control-with-amazon-cloudfront/">Amazon</a>, <a href="https://cloud.google.com/blog/products/networking/tcp-bbr-congestion-control-comes-to-gcp-your-internet-just-got-faster">Google</a>. В определённых случаях можно ожидать и кратного увеличения скорости TCP-соединения.</p>
<p>Т. к. BBR является алгоритмом TCP congestion control, то включается он на отправляющей стороне. Т. е., включив его на своём ноутбуке, вы улучшите upload данных, а чтобы улучшить download, он должен быть включён на сервере. При этом, само собой, включение его на одной стороне не требует какой-либо поддержки на другой, т. к. меняются только эвристики внутри TCP-протокола, а не сам протокол.</p>
<h2 id="критика">Критика</h2>
<p>Не обошлось правда и без <a href="https://huitema.wordpress.com/2019/01/12/will-transport-innovation-collapse-the-internet/">критики</a> данного алгоритма. Всё дело в том, что по сравнению со стандартным CUBIC&rsquo;ом, BBR ведёт себя достаточно агрессивно, и может получиться так, что если вы, скажем, включите его на своем Linux-ноутбуке и начнёте заливать большие файлы в сеть, то ваш BBR-ноутбук может запросто &ldquo;задушить&rdquo; TCP-соединения соседних устройств, использующих традиционные алгоритмы TCP congestion control (а в MacOS, к примеру, BBR и вовсе недоступен).</p>
<p>Есть инициатива в виде <a href="https://datatracker.ietf.org/meeting/112/materials/slides-112-iccrg-bbrv2-update-00">BBRv2</a>, которая пытается решить эту проблему, но пока что в ядре используется первая версия, и надо эту особенность иметь в виду.</p>
<h2 id="эффект-от-bbr-применительно-к-tcp-тоннелю">Эффект от BBR применительно к TCP-тоннелю</h2>
<p>Так вот, почитав всё это, я с одной стороны обрадовался (какая многообещающая штука – надо пробовать!), а с другой – тут же взгрустнул: включать BBR нужно на конечных устройствах (сервер + клиент), а на роутере его включать бесполезно, т. к. при forwarding&rsquo;е пакетов все эти алгоритмы по понятным причинам не задействованы. Но на серверную часть я повлиять не могу, а в качестве клиентской у меня ноутбук с MacOS, в котором BBR и вовсе нет. С другой стороны – подумал я – у меня ведь по факту два TCP-соединения: одно между ноутбуком и конечным сервером, а другое – между двумя точками тоннеля, которые находятся на Linux-серверах, и вот на это соединение я повлиять могу.</p>
<p>Чтож, попробуем&hellip; Включил его для TCP-соединения своего тоннеля – и тут же получил 2.5x скорость при скачивании файлов! Если раньше что с UDP, что с TCP-транспортом у меня абсолютным максимумом было 30 Mbit/s, то после включения BBR оно тут же скакнуло до 75 Mbit/s.</p>
<p>Лично я такие результаты объясняю себе следующим: гоняя тоннельный траффик по TCP, я маскирую все потери пакетов между двумя точками тоннеля для TCP-соединений, которые в него заворачиваются. И даже если они используют традиционные алгоритмы, основанные на потерях пакетов, то теперь они этих потерь не замечают и не сбрасывают скорость почём зря. Ну а дальше уже эти данные передаются по TCP-соединению тоннеля с BBR, который максимизирует скорость передачи данных.</p>
<p>В итоге я пришёл к следующему: если раньше я всегда в качестве транспорта использовал UDP, и переключение на TCP вызывало заметные глазу подтормаживания при загрузке страниц в браузере, то теперь, когда у меня TCP работает с BBR, картина поменялась на противоположную: UDP выдаёт вполне приемлемый результат, но если переключиться на TCP, то невооружённым глазом становится видно, что всё начинает подгружаться ещё быстрее. Учитывая то, что TCP-тоннель ещё и можно замаскировать под обычное HTTPS-соединение, получается, что в использовании UDP и вовсе нет смысла. Единственное, в чём UDP по прежнему обходит TCP + BBR – это в latency: если запустить ping и начать грузить канал, то в случае с UDP latency ping&rsquo;ов практически не меняется, в то время как с TCP (с BBR и без) оно может увеличиваться до четырёх раз. Но т. к. это довольно синтетический тест, а при реальном использовании с браузером, как я описал выше, я вижу противоположные результаты, то для меня это не выглядит проблемой.</p>
<h2 id="включение">Включение</h2>
<p>Включается BBR очень просто:</p>
<p><code>sysctl net.ipv4.tcp_available_congestion_control</code> показывает список доступных алгоритмов. Скорее всего, по умолчанию BBR там не будет:</p>
<pre tabindex="0"><code>$ sudo sysctl net.ipv4.tcp_available_congestion_control
net.ipv4.tcp_available_congestion_control = reno cubic
</code></pre><p>– это потому, что не загружен соответствующий модуль ядра.</p>
<ol>
<li>Загружаем модуль – <code>modprobe tcp_bbr</code> (или <code>echo tcp_bbr &gt; /etc/modules-load.d/bbr.conf</code>, чтобы он загружался автоматом при старте системы).</li>
<li>Включаем BBR – <code>sysctl net.ipv4.tcp_congestion_control=bbr</code> (или <code>echo 'net.ipv4.tcp_congestion_control = bbr' &gt; /etc/sysctl.d/bbr.conf</code>, чтобы он включался автоматом при старте системы). На всякий случай замечу, что, несмотря на префикс <code>net.ipv4.*</code>, включение происходит как для IPv4, так и для IPv6.</li>
</ol>
<p>При этом его можно включить не для всех, а только для отдельных TCP-соединений, передав опцию <a href="https://man7.org/linux/man-pages/man7/tcp.7.html">TCP_CONGESTION</a> в <a href="https://man7.org/linux/man-pages/man2/setsockopt.2.html">setsockopt(2)</a>. И даже у <code>iperf</code> есть опция <code>-C bbr</code>, с помощью которой можно протестировать поведение различных алгоритмов TCP congestion control конкретно для вашего случая.</p>
<h2 id="last-but-not-least">Last, but not least</h2>
<p>В процессе изучения всего вышеописанного я абсолютно случайно для себя узнал, что в то время как во всех современных дистрибутивах благодаря systemd уже давно в качестве <a href="https://www.linuxjournal.com/content/queueing-linux-network-stack">queueing discipline</a> по умолчанию включена <code>fq_codel</code>, которая считается наиболее оптимальным general purpose вариантом, то в Debian/Ubuntu меинтейнеры не смогли преодолеть свою внутреннюю бюрократию – и даже в самых современных Debian/Ubuntu по умолчанию используется <code>pfifo_fast</code>: они не включают в systemd-пакет его <a href="https://github.com/systemd/systemd/blob/main/sysctl.d/50-default.conf">стандартный конфиг</a>, но в то же время не смогли найти &ldquo;правильное место&rdquo;, куда можно было бы положить аналогичные разумные default&rsquo;ы – и в результате используется значение по умолчанию, которое установлено в ядре.</p>
<p><code>pfifo_fast</code> – это самая простая queueing discipline, которая никак не приоритезирует пакеты между различными сетевыми соединениями, и может получиться так, что самое активное из них будет сильно увеличивать latency всех остальных.</p>
<p>Поэтому рекомендую всем пользователям Debian/Ubuntu добавить <code>/etc/sysctl.d/00-qdisc.conf</code> со следующим содержимым:</p>
<pre tabindex="0"><code>net.core.default_qdisc = fq_codel
</code></pre><p>чтобы исправить это недоразумение.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>gmailctl: наводим порядок в своей почте</title>
      <link>https://konishchev.ru/posts/gmailctl/</link>
      <pubDate>Mon, 08 Apr 2024 19:25:58 +0300</pubDate>
      
      <guid>https://konishchev.ru/posts/gmailctl/</guid>
      <description>У меня довольно большое количество фильтров в Gmail, которое уже давно не влезает на один экран монитора, и при этом интерфейс управления этими фильтрами в Gmail настолько примитивен, что не даёт абсолютно никаких возможностей их хоть как-то организовать. Поэтому каждый раз, когда раньше возникала необходимость добавить новый фильтр (а гораздо хуже – изменить существующий), я мысленно вздыхал – и шёл в этот ужасно неудобный интерфейс&amp;hellip; пока случайно не наткнулся на gmailctl.</description>
      <content:encoded><![CDATA[<p>У меня довольно большое количество фильтров в Gmail, которое уже давно не влезает на один экран монитора, и при этом интерфейс управления этими фильтрами в Gmail настолько примитивен, что не даёт абсолютно никаких возможностей их хоть как-то организовать. Поэтому каждый раз, когда раньше возникала необходимость добавить новый фильтр (а гораздо хуже – изменить существующий), я мысленно вздыхал – и шёл в этот ужасно неудобный интерфейс&hellip; пока случайно не наткнулся на gmailctl.</p>
<p><a href="https://github.com/mbrt/gmailctl">gmailctl</a> – это абсолютно потрясающая утилитка, которая позволяет вовсе не использовать web-интерфейс редактирования правил обработки почты и унести их в локальный конфиг. У неё свой язык описания правил (имеющий свои преимущества), который она затем преобразовывает в формат Gmail и заменяет все существующие фильтры на описанные в вашем конфиге (не забыв при этом показать аккуратный diff изменений).</p>
<p>Правила могут быть как очень простые:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  filter: {from: <span style="color:#a31515">&#34;linkedin.com&#34;</span>},
</span></span><span style="display:flex;"><span>  actions: label(<span style="color:#a31515">&#34;LinkedIn&#34;</span>),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>так и довольно развесистые:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  filter: {or: [
</span></span><span style="display:flex;"><span>    {and: [{from: <span style="color:#a31515">&#34;notifications@github.com&#34;</span>}, {subject: <span style="color:#a31515">&#34;[KonishchevDmitry/&#34;</span>}, {subject: <span style="color:#a31515">&#34;] Release&#34;</span>}]},
</span></span><span style="display:flex;"><span>    {and: [{from: <span style="color:#a31515">&#34;cloud@support.yandex.ru&#34;</span>}, {or: [
</span></span><span style="display:flex;"><span>      {subject: <span style="color:#a31515">&#34;You have been given a grant&#34;</span>},
</span></span><span style="display:flex;"><span>      {subject: <span style="color:#a31515">&#34;Planned maintenance&#34;</span>},
</span></span><span style="display:flex;"><span>    ]}]},
</span></span><span style="display:flex;"><span>    {and: [{from: <span style="color:#a31515">&#34;noreply@market.yandex.ru&#34;</span>}, {or: [
</span></span><span style="display:flex;"><span>      {subject: <span style="color:#a31515">&#34;Вы оформили и оплатили заказ&#34;</span>},
</span></span><span style="display:flex;"><span>      {and: [{subject: <span style="color:#a31515">&#34;Заказ&#34;</span>}, {subject: <span style="color:#a31515">&#34;доставлен&#34;</span>}]},
</span></span><span style="display:flex;"><span>    ]}]},
</span></span><span style="display:flex;"><span>    {and: [{from: <span style="color:#a31515">&#34;mailer@sender.ozon.ru&#34;</span>}, {subject: <span style="color:#a31515">&#34;Вам понравился заказ?&#34;</span>}]},
</span></span><span style="display:flex;"><span>    {and: [{from: <span style="color:#a31515">&#34;mosenergosbyt.ru&#34;</span>}, {subject: <span style="color:#a31515">&#34;Электронный счёт за&#34;</span>}]},
</span></span><span style="display:flex;"><span>  ]},
</span></span><span style="display:flex;"><span>  actions: <span style="color:#00f">delete</span>(),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Увидев это чудо, я в тот же день переколбасил все свои правила и полностью перешел на gmailctl. Они по-прежнему занимают несколько экранов монитора, но зато теперь их можно организовать удобным мне образом, объявлять функции и переменные, ставить комментарии, отделять отступами и т. п. В общем, всё как в любых нормальных декларативных языках.</p>
<p>Крайне рекомендую. Невероятно полезная и удобная вещь для всех, у кого больше десятка фильтров в Gmail.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Проблемы обратной совместимости glibc</title>
      <link>https://konishchev.ru/posts/glibc-static-linking/</link>
      <pubDate>Wed, 27 Mar 2024 21:57:31 +0300</pubDate>
      
      <guid>https://konishchev.ru/posts/glibc-static-linking/</guid>
      <description>В своей работе я не раз сталкивался с тем, что, собрав Go/Rust-программу на своей рабочей машине и скопировав её на другую, с более старой версией дистрибутива, есть большой шанс того, что она при запуске упадёт с ошибкой вида /lib/x86_64-linux-gnu/libc.so.6: version `GLIBC_2.38&#39; not found. Обычно разбираться всегда было некогда, и я просто пересобирал свою программу на нужной версии дистрибутива, но вот тут стало интересно – и я пошёл посмотреть, как скомпилить свою Rust&amp;rsquo;овую программу статически с glibc, чтобы не иметь таких проблем.</description>
      <content:encoded><![CDATA[<p>В своей работе я не раз сталкивался с тем, что, собрав Go/Rust-программу на своей рабочей машине и скопировав её на другую, с более старой версией дистрибутива, есть большой шанс того, что она при запуске упадёт с ошибкой вида <code>/lib/x86_64-linux-gnu/libc.so.6: version `GLIBC_2.38' not found</code>. Обычно разбираться всегда было некогда, и я просто пересобирал свою программу на нужной версии дистрибутива, но вот тут стало интересно – и я пошёл посмотреть, как скомпилить свою Rust&rsquo;овую программу статически с glibc, чтобы не иметь таких проблем. В результате узнал для себя что-то новое и делюсь своими находками.</p>
<h2 id="glibc">glibc</h2>
<p>Первая мысль была довольно предсказуемой и понятной: &ldquo;пойду-ка посмотрю, как собрать статически Rust&rsquo;овый бинарь с glibc&rdquo; – и, на самом деле, особых проблем с этим нет. Надо всего лишь сделать вот так:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>RUSTFLAGS=<span style="color:#a31515">&#39;-C target-feature=+crt-static&#39;</span> cargo build --release --target x86_64-unknown-linux-gnu
</span></span></code></pre></div><p>– и оно работает, программа запускается без проблем!</p>
<p>Но, если покопать эту тему чуть более подробно, то выясняется, что решение это на самом деле – так себе. Всё дело в том, что glibc так устроена, что она в принципе не особо предназначена для статической линковки: из-за <a href="http://man7.org/linux/man-pages/man5/nsswitch.conf.5.html">NSS</a>, <a href="http://man7.org/linux/man-pages/man3/iconv.3.html"><code>iconv(3)</code></a> и пр. она полагается на <a href="http://man7.org/linux/man-pages/man3/dlopen.3.html"><code>dlopen(3)</code></a>, и определённые функции стандартной библиотеки могут стриггерить, скажем, загрузку NSS-модуля, который является динамически разделяемой библиотекой, к тому же динамически слинкованной с glibc, что в свою очередь может привести к ситуации, когда у нас в адресном пространстве приложения будут загружены две glibc: статическая и динамически подгруженная через зависимость NSS-модуля, что в итоге может привести к разным интересным последствиям (к примеру, как они будут делить буферы <code>stdout</code>?). Внутри неё на самом деле есть различные подпорки, чтобы статическая сборка всё-таки нормально работала в большинстве случаев, но вот только гарантий, что она будет работать во всех возможных сценариях – нет.</p>
<p>В итоге, большинство людей сходятся в том, что статическую сборку с glibc лучше не использовать, т. к. мы тут идём против её дизайна и рискуем получить неожиданные последствия от таких действий. И самый оптимальный вариант тут – использовать для сборки Docker-контейнер с каким-нибудь заведомо не самым свежим LTS-дистрибутивом – и линковаться против glibc его версии.</p>
<p>Но также есть и другие варианты.</p>
<h2 id="musl">musl</h2>
<p>Напомню, что Linux – это только ядро, а не операционная система. Интерфейсом к ядру являются системные вызовы, и поэтому ничто не мешает нам вместо glibc использовать что-то другое. Наиболее распространённом вариантом в данном случае является <a href="https://musl.libc.org/">musl</a>.</p>
<p>Честно говоря, я musl до этого момента ни разу не пользовался, т. к. мне всегда казалось довольно странным использовать что-то нестандартное вместо glibc – обязательно ведь где-нибудь что-нибудь будет работать по-другому, и можно нарваться на какие-нибудь неприятные сюрпризы в самый неподходящий на то момент. Поэтому всегда считал, что её использование имеет смысл разве что в embedded, либо где-нибудь вроде <a href="https://www.alpinelinux.org/">Alpine</a>, где нам по какой-то причине хочется получить максимально компактный образ.</p>
<p>Но если смотреть с позиции статической линковки, использование musl вполне имеет смысл, т. к. для неё, в отличие от glibc, статическая линковка является абсолютно стандартным вариантом использования.</p>
<p>Поэтому (в случае Rust) выполняем:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>rustup target add x86_64-unknown-linux-musl
</span></span><span style="display:flex;"><span>cargo build --target x86_64-unknown-linux-musl
</span></span></code></pre></div><p>– и получаем то, что нам нужно. Правда, свои &ldquo;но&rdquo; тут тоже есть&hellip;</p>
<p>musl ставит своей целью быть компактной и простой в реализации, и, как это часто бывает, когда кто-то ставит себе такую цель, то порой оказывается, что некоторые вещи в принципе не должны быть простыми, и слишком простая их реализация приводит к проблемам.</p>
<p>В результате чего нередки ситуации, когда наша программа, которая без проблем работала с glibc, вдруг перестаёт работать из-за того, что <a href="https://purplecarrot.co.uk/post/2021-09-04-does_alpine-resolve_dns_properly/">в musl DNS resolver не поддерживает ответы с большим количеством записей</a> (на самом деле уже <a href="https://www.furorteutonicus.eu/2023-10-02-musl-alpine-dns">исправлено</a>), либо работает в десятки (!) раз медленнее – <a href="https://www.linkedin.com/pulse/testing-alternative-c-memory-allocators-pt-2-musl-mystery-gomes/">раз</a>, <a href="https://andygrove.io/2020/05/why-musl-extremely-slow/">два</a>, <a href="https://twitter.com/theomn/status/1149853793636368384">три</a> (как правило, в случае интенсивной аллокации памяти из нескольких потоков одновременно, но также это может быть связано и с тем, что &ldquo;раздутая&rdquo; glibc использует AVX и прочие инструкции для оптимизации своих функций, а &ldquo;простая и компактная&rdquo; musl – нет), либо у вас какая-то специфическая конфигурация, в которой проявляются <a href="https://github.com/gliderlabs/docker-alpine/blob/460819debdada8db435a3619c688a702bdd3420b/docs/caveats.md">отличия в реализации glibc и musl</a>. Ну и, понятное дело, musl не подойдет, если вам нужен NSS (к примеру, в случае с LDAP).</p>
<p>В итоге, я бы сказал, что если у вас в качестве приложения довольно простая command line-утилита, то скорее всего проблем не будет – и для простоты можно статически линковаться с musl, но если у вас какой-то навороченный/высоконагруженный сервис, то либо стоит быть готовым к сюрпризам, либо использовать более сложную конфигурацию вроде musl + <a href="https://github.com/microsoft/mimalloc">mimalloc</a>/<a href="https://jemalloc.net/">jemalloc</a> в качестве аллокатора.</p>
<h2 id="eyra">Eyra</h2>
<p>Если говорить о Rust, то на самом деле есть ещё один интересный вариант – <a href="https://github.com/sunfishcode/eyra/">Eyra</a>. Данный проект ставит своей целью реализовать все функции стандартной библиотеки на Rust и линковаться в процессе сборки с ними.</p>
<p>Этот вариант я, честно говоря, даже не пробовал (уж больно молодой проект), но идея интересная и многообещающая.</p>
<h2 id="интересный-факт">Интересный факт</h2>
<p>Я этого не знал, но, оказывается, ABI системных вызовов стабильный только у Linux. В Windows и MacOS он может меняться абсолютно непредсказуемым образом (даже в минорных версиях), и стабильным является только API стандартной библиотеки (<code>ntdll.dll</code> в Windows и <code>libSystem.dylib</code> в MacOS). И там такой опции у нас вовсе нет.</p>
<p>Go даже поначалу пытался идти тут против течения, но в итоге <a href="https://golang.org/doc/go1.11#runtime">сдался</a>.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Перезапуск блога</title>
      <link>https://konishchev.ru/posts/blog-again/</link>
      <pubDate>Tue, 26 Mar 2024 13:23:06 +0300</pubDate>
      
      <guid>https://konishchev.ru/posts/blog-again/</guid>
      <description>Больше 11 лет прошло с момента моего последнего поста в блоге KonishchevDmitry&amp;rsquo;s small blog, который я вёл когда-то давно и достаточно активно.
И вот какое-то время назад появилось желание попробовать его возродить в том или ином виде, т. к. всё равно время от времени появляются мысли, которыми хотелось бы поделиться в силу того, что они могут быть кому-то полезны. Причём сейчас такое интересное время, что даже если твой пост не смог пробиться сквозь поисковую выдачу, то кто знает – может какая-то его часть сможет обогатить базу знаний условного ChatGPT, и он потом на какие-то вопросы будет отвечать в своей уверенной манере фразами из твоего блога, тем самым таргетированно нанося кому-то пользу.</description>
      <content:encoded><![CDATA[<p>Больше 11 лет прошло с момента моего последнего поста в блоге <a href="https://konishchevdmitry.blogspot.com/">KonishchevDmitry&rsquo;s small blog</a>, который я вёл когда-то давно и достаточно активно.</p>
<p>И вот какое-то время назад появилось желание попробовать его возродить в том или ином виде, т. к. всё равно время от времени появляются мысли, которыми хотелось бы поделиться в силу того, что они могут быть кому-то полезны. Причём сейчас такое интересное время, что даже если твой пост не смог пробиться сквозь поисковую выдачу, то кто знает – может какая-то его часть сможет обогатить базу знаний условного ChatGPT, и он потом на какие-то вопросы будет отвечать в своей уверенной манере фразами из твоего блога, тем самым таргетированно нанося кому-то пользу. :)</p>
<p>Свободного времени у меня теперь заметно меньше чем раньше, и вряд ли я буду писать сюда часто, но раз желание появилось – то надо попробовать, а там уж посмотрим, что из этого выйдет.</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
